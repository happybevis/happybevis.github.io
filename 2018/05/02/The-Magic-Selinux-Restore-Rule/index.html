<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="前些日子，老大的手机没电了，充电开机后一直卡在开机动画不断转啊转。立马将手机借来分析，由此便有了这篇文章。网上讲sepolicy的文章很多，尤其”Innost大神的专栏 “讲的特别好（分一二两篇），所以其基础部分在此便不再赘述。 本文主要介绍的是Android Sepolicy对某些特定资料夹（如/data/data等）的独特管理方式，并介绍restorecon工具在Android系统中的使用注意">
<meta property="og:type" content="article">
<meta property="og:title" content="神奇的Selinux Restore Rule">
<meta property="og:url" content="http://happybevis.github.io/2018/05/02/The-Magic-Selinux-Restore-Rule/index.html">
<meta property="og:site_name" content="Happybevis">
<meta property="og:description" content="前些日子，老大的手机没电了，充电开机后一直卡在开机动画不断转啊转。立马将手机借来分析，由此便有了这篇文章。网上讲sepolicy的文章很多，尤其”Innost大神的专栏 “讲的特别好（分一二两篇），所以其基础部分在此便不再赘述。 本文主要介绍的是Android Sepolicy对某些特定资料夹（如/data/data等）的独特管理方式，并介绍restorecon工具在Android系统中的使用注意">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-05-10T11:59:58.186Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="神奇的Selinux Restore Rule">
<meta name="twitter:description" content="前些日子，老大的手机没电了，充电开机后一直卡在开机动画不断转啊转。立马将手机借来分析，由此便有了这篇文章。网上讲sepolicy的文章很多，尤其”Innost大神的专栏 “讲的特别好（分一二两篇），所以其基础部分在此便不再赘述。 本文主要介绍的是Android Sepolicy对某些特定资料夹（如/data/data等）的独特管理方式，并介绍restorecon工具在Android系统中的使用注意">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://happybevis.github.io/2018/05/02/The-Magic-Selinux-Restore-Rule/"/>





  <title>神奇的Selinux Restore Rule | Happybevis</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?72c4d0c50df21fb0d79918609f271f9b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Happybevis</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://happybevis.github.io/2018/05/02/The-Magic-Selinux-Restore-Rule/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bevis">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Happybevis">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">神奇的Selinux Restore Rule</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-02T11:14:54+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>前些日子，老大的手机没电了，充电开机后一直卡在开机动画不断转啊转。立马将手机借来分析，由此便有了这篇文章。网上讲sepolicy的文章很多，尤其”<a href="https://blog.csdn.net/innost/article/details/19299937" target="_blank" rel="noopener">Innost大神的专栏</a> “讲的特别好（分一二两篇），所以其基础部分在此便不再赘述。</p>
<p>本文主要介绍的是Android Sepolicy对某些特定资料夹（如/data/data等）的独特管理方式，并介绍restorecon工具在Android系统中的使用注意事项。</p>
<h2 id="案例：一个由selinux权限变化所引发的血案"><a href="#案例：一个由selinux权限变化所引发的血案" class="headerlink" title="案例：一个由selinux权限变化所引发的血案"></a>案例：一个由selinux权限变化所引发的血案</h2><p>前面说到老板的手机突然挂了，立马把手机借来，经过一系列操作后终于成功抓取到系统开机log，有了log很容易就定位到导致系统无法开机的直接原因：在Android Runtime做dexopt时，因无权限访问/data/app文件路径下的3rd party apk，从而造成java虚拟机重启/加载/crash的不断循环。 </p>
<p>对比正常机器，发现一个<strong>神奇</strong>的现象：<strong>该机器中“/data/app”目录的Selinux权限居然被人改成了unlabeled</strong>，如此一来java runtime的访问权限就活生生地被selinux挡死了。</p>
<p>通常况下的/data/app资料夹权限应为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u:object_r:apk_data_file:s0       /data/app</span><br></pre></td></tr></table></figure></p>
<p>而老大的手机中却变为了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u:object_r:unlabeled:s0         /data/app</span><br></pre></td></tr></table></figure></p>
<p>由此就引申出如下几个需要我们搞清楚的问题点：</p>
<ul>
<li><p>check 源代码，发现在init.rc的 post-fs-data默认就有做“restorecon /data”的行为，但为何开机后”/data/app“目录却没有被重新relabel？(在file_contexts 文件中已经定义过 /data/app(/.*)?   u:object_r:apk_data_file:s0)</p>
</li>
<li><p>unlabeled的selinux label是如何被误打到/data/app文件夹中去的？</p>
</li>
</ul>
<p>让我们来顺着这些问题，谈谈selinux针对某些特殊文件夹的label rule。</p>
<h2 id="Android系统中嵌入的selinux辅助工具"><a href="#Android系统中嵌入的selinux辅助工具" class="headerlink" title="Android系统中嵌入的selinux辅助工具"></a>Android系统中嵌入的selinux辅助工具</h2><blockquote>
<ul>
<li>getenforce : 获取当前selinux的开关状态。Enforcing : Selinux On; Permissive : Selinux OFF;</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>setenforce :设置以开关selinux。 0 : 关闭 ;  1 : 打开;</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>chcon : 随意修改某个文件(夹)的selinux lable。Ex: chcon u:object_r:system_data_file:s0  /data/app</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>restorecon : 依照sepolicy Rule中定义的规则，重新relable指定的文件(夹)。</li>
</ul>
</blockquote>
<p>这里我主要要介绍下最后一条命令“restorecon”，其工作方式对解决前面提出的疑问有极大帮助。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">usage: restorecon [-D] [-F] [-R] [-n] [-v] FILE...</span><br><span class="line"></span><br><span class="line">Restores the default security contexts for the given files.</span><br><span class="line"></span><br><span class="line">-D	apply to /data/data too</span><br><span class="line">-F	force reset</span><br><span class="line">-R	recurse into directories</span><br><span class="line">-n	don&apos;t make any changes; useful with -v to see what would change</span><br><span class="line">-v	verbose: show any changes</span><br></pre></td></tr></table></figure>
<h3 id="restorecon-R（recurse）"><a href="#restorecon-R（recurse）" class="headerlink" title="restorecon -R（recurse）"></a>restorecon -R（recurse）</h3><p>默认不加参数状况下的restorecon命令与chcon命令的唯一差别的，前者会依照编译进系统的file_contexts rule来对指定的文件(夹)进行lable(在Android O之前，该rule文件放在boot img中)。</p>
<p>当我们加入-R参数后，该命令将会遍历所指定的文件夹，并依照编译进系统的file_contexts rule对每个文件进行label动作。注意：需要在repolicy enable的前提下才能正常使用。</p>
<p>值得注意的是，selinux的有如下规则：在未定义selinux label rule的前提下，文件夹中建立的新文件默认将会继承母文件夹的selinux label。当然，赋予特殊权限的进程是有能力修改新建文件selinux label的。</p>
<p>大家知道在Android系统中，app的数据资料默认会放到/data/data目录下以apk包名命名的各自资料夹中，根据apk享有的权限不同，其资料夹下的selinux label就自然会不一样，由于我们无法预先得知其需要的label，且file_contexts文件中定义的rule几乎都是通配符规则，故若不加以合理的管控，系统若调用了restorecon -R则/data/data下的selinux lable就全被改坏了。</p>
<p>针对此情况，Android系统对一些目录做了特殊处理，及时调用restorecon -R命令，依然直接skip relable过程，以保留Android 虚拟机对app selinux权限的管理能力。</p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ASUS_Z01R_1:/ # restorecon  -R /data/</span><br><span class="line">SELinux: Loaded file_contexts</span><br><span class="line">SELinux: Skipping restorecon_recursive(/data)</span><br></pre></td></tr></table></figure></p>
<p>注意：如下这些目录都是-R命令会自动忽略处理label动作的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/data/data</span><br><span class="line">/data/user</span><br><span class="line">/data/user_de</span><br><span class="line">/mnt/expand/\?\?\?\?\?\?\?\?-\?\?\?\?-\?\?\?\?-\?\?\?\?-\?\?\?\?\?\?\?\?\?\?\?\?/user</span><br><span class="line">/mnt/expand/\?\?\?\?\?\?\?\?-\?\?\?\?-\?\?\?\?-\?\?\?\?-\?\?\?\?\?\?\?\?\?\?\?\?/user_de</span><br></pre></td></tr></table></figure>
<h3 id="restorecon-D"><a href="#restorecon-D" class="headerlink" title="restorecon -D"></a>restorecon -D</h3><p>在Android系统的实际实现中，该参数实际执行过程中，除了如help文档所描述的/data/data/也强行relabel外，对前面描述的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/data/data</span><br><span class="line">/data/user</span><br><span class="line">/data/user_de</span><br><span class="line">/mnt/expand/\?\?\?\?\?\?\?\?-\?\?\?\?-\?\?\?\?-\?\?\?\?-\?\?\?\?\?\?\?\?\?\?\?\?/user</span><br><span class="line">/mnt/expand/\?\?\?\?\?\?\?\?-\?\?\?\?-\?\?\?\?-\?\?\?\?-\?\?\?\?\?\?\?\?\?\?\?\?/user_de</span><br></pre></td></tr></table></figure></p>
<p>也同样会进行relabel动作。</p>
<p>实际实现文件为：<br>external/selinux/libselinux/src/android/android.c<br>external/toybox/toys/android/restorecon.c </p>
<h3 id="restorecon-F"><a href="#restorecon-F" class="headerlink" title="restorecon -F"></a>restorecon -F</h3><p>前面有讲，在-R参数(recurse)加入后，虽然是遍历执行relabel模式，但有些文件夹<br>却被强行跳过relabel过程，说明有些情况系统已经打入的label其实并不需要频繁更新。</p>
<p>该参数的效果是，对除</p>
<blockquote>
<ol>
<li><p>/data/data<br>/data/user<br>/data/user_de<br>/mnt/expand/\?\?\?\?\?\?\?\?-\?\?\?\?-\?\?\?\?-\?\?\?\?-\?\?\?\?\?\?\?\?\?\?\?\?/user<br>/mnt/expand/\?\?\?\?\?\?\?\?-\?\?\?\?-\?\?\?\?-\?\?\?\?-\?\?\?\?\?\?\?\?\?\?\?\?/user_de</p>
</li>
<li><p>/sys</p>
</li>
<li><p>文件node属于in-memory filesystems的RAMFS</p>
</li>
</ol>
<p>下文中我们把这些情况成为[情况A]</p>
</blockquote>
<p>三种文件路径外的所有文件(夹)，强制进行relabel动作，一般需要搭配-R命令使用。</p>
<p>可能有人会有疑惑，前面的-R参数不是说对除某些特定文件夹外的所有文件进行relabel动作，为何这里还要进行force reset呢？</p>
<p>其实，为了防止在调用restorecon -R命令时，不必要的子文件夹selinux权限被无意义或错误地改动，所以对[情况A]外的所有节点，会多进行一次传入文件根路径的selinux label check，若该节点的selinux lable和编译预设的file_contexts规则一致，则直接跳出后续流程，即不进行任何子目录的遍历relabel过程。</p>
<p>加入-F参数后，selinux core就不再进行传入文件节点和预编译file_contexts规则的匹配判断，从而继续执行后续的relabel动作。不过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/data/data</span><br><span class="line">/data/user</span><br><span class="line">/data/user_de</span><br><span class="line">/mnt/expand/\?\?\?\?\?\?\?\?-\?\?\?\?-\?\?\?\?-\?\?\?\?-\?\?\?\?\?\?\?\?\?\?\?\?/user</span><br><span class="line">/mnt/expand/\?\?\?\?\?\?\?\?-\?\?\?\?-\?\?\?\?-\?\?\?\?-\?\?\?\?\?\?\?\?\?\?\?\?/user_de）</span><br></pre></td></tr></table></figure></p>
<p>几个目录依然会自动跳出，不进行遍历以保证Android app的上层权限管理机制不被影响到。</p>
<h2 id="深入理解Android-init-rc-命令中集成的restorecon命令"><a href="#深入理解Android-init-rc-命令中集成的restorecon命令" class="headerlink" title="深入理解Android init.rc 命令中集成的restorecon命令"></a>深入理解Android init.rc 命令中集成的restorecon命令</h2><p>前面我们学会了如何使用系统工具中带入的restorecon命令，其实init.rc中也集成了restorecon命令，不过并没有集成所有的功能(例如无-F功能支持)。</p>
<p>在init.rc中支援如下两个restorecon命令:</p>
<blockquote>
<p>restorecon<br>restorecon_recursive</p>
</blockquote>
<h3 id="rc文件中的restorecon命令"><a href="#rc文件中的restorecon命令" class="headerlink" title="rc文件中的restorecon命令"></a>rc文件中的restorecon命令</h3><p>该命令在rc文件中对应前面讲过的工具中restorecon命令，不够所支援的参数为如下三个：</p>
<blockquote>
<p>–recursive： 遍历执行，同工具命令的restorecon -R<br>–skip-ce ： 跳过”/data/system_ce/“和”/data/misc_ce/“目录的relabel遍历过程。<br>–cross-filesystems ： open文件节点时，以少一个 FTS_XDEV flag的方式打开。由于用的比较少，故和不加该参数的差异还未做研究。</p>
</blockquote>
<p>如rc文件中的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">restorecon --recursive --skip-ce /data</span><br><span class="line">restorecon /adb_keys</span><br></pre></td></tr></table></figure></p>
<h3 id="rc文件中的restorecon-recursive命令"><a href="#rc文件中的restorecon-recursive命令" class="headerlink" title="rc文件中的restorecon_recursive命令"></a>rc文件中的restorecon_recursive命令</h3><p>该命令其实就是对restorecon –recursive命令的封装，两者完全等价。<br>另外，该命令还是可以继续加入其他剩余的两个参数。</p>
<p>如rc文件中的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">restorecon_recursive /mnt</span><br><span class="line">restorecon --recursive --cross-filesystems /sys/kernel/debug</span><br><span class="line">restorecon --recursive --skip-ce /data</span><br></pre></td></tr></table></figure></p>
<h3 id="restorecon和restorecon-recursive在init中的具体实现"><a href="#restorecon和restorecon-recursive在init中的具体实现" class="headerlink" title="restorecon和restorecon_recursive在init中的具体实现"></a>restorecon和restorecon_recursive在init中的具体实现</h3><p>下面我们跟踪代码，探索Android系统中label过程的具体实现过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/* File name :/system/core/init/builtins.cpp*/</span><br><span class="line"> static const Map builtin_functions = &#123;</span><br><span class="line"> ...</span><br><span class="line">    &#123;&quot;restorecon&quot;,              &#123;1,     kMax, do_restorecon&#125;&#125;,</span><br><span class="line">    &#123;&quot;restorecon_recursive&quot;,    &#123;1,     kMax, do_restorecon_recursive&#125;&#125;,</span><br><span class="line">    //定义rc文件中支援的命令restorecon/restorecon_recursive及对应的实现函数</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">static int do_restorecon(const std::vector&lt;std::string&gt;&amp; args) &#123;</span><br><span class="line">    int ret = 0;</span><br><span class="line"></span><br><span class="line">    struct flag_type &#123;const char* name; int value;&#125;;</span><br><span class="line">    static const flag_type flags[] = &#123;</span><br><span class="line">        &#123;&quot;--recursive&quot;, SELINUX_ANDROID_RESTORECON_RECURSE&#125;,</span><br><span class="line">        &#123;&quot;--skip-ce&quot;, SELINUX_ANDROID_RESTORECON_SKIPCE&#125;,</span><br><span class="line">        &#123;&quot;--cross-filesystems&quot;, SELINUX_ANDROID_RESTORECON_CROSS_FILESYSTEMS&#125;,</span><br><span class="line">        &#123;0, 0&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    //在rc命令中，增加支援的三个参数。注意，可以看出其并不支援force reset参数。</span><br><span class="line"></span><br><span class="line">    int flag = 0;</span><br><span class="line"></span><br><span class="line">    bool in_flags = true;</span><br><span class="line">    for (size_t i = 1; i &lt; args.size(); ++i) &#123;</span><br><span class="line">        if (android::base::StartsWith(args[i], &quot;--&quot;)) &#123;</span><br><span class="line">            if (!in_flags) &#123;</span><br><span class="line">                LOG(ERROR) &lt;&lt; &quot;restorecon - flags must precede paths&quot;;</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">            bool found = false;</span><br><span class="line">            for (size_t j = 0; flags[j].name; ++j) &#123;</span><br><span class="line">                if (args[i] == flags[j].name) &#123;</span><br><span class="line">                    flag |= flags[j].value;</span><br><span class="line">                    found = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!found) &#123;</span><br><span class="line">                LOG(ERROR) &lt;&lt; &quot;restorecon - bad flag &quot; &lt;&lt; args[i];</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            in_flags = false;</span><br><span class="line">            if (restorecon(args[i].c_str(), flag) &lt; 0) &#123;    //调用restorecon函数进行restore label过程。</span><br><span class="line">                ret = -errno;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int do_restorecon_recursive(const std::vector&lt;std::string&gt;&amp; args) &#123;</span><br><span class="line">    std::vector&lt;std::string&gt; non_const_args(args);</span><br><span class="line">    non_const_args.insert(std::next(non_const_args.begin()), &quot;--recursive&quot;); //相比restorecon命令而言，只是默认多传入一个&quot;--recursive&quot;参数而已，后面流程完全一样。</span><br><span class="line">    return do_restorecon(non_const_args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面restorecon函数的最终实现实在如下位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line">/* File name : external/selinux/libselinux/src/android/android.c */</span><br><span class="line">static int selinux_android_restorecon_common(const char* pathname_orig,</span><br><span class="line">                                             const char *seinfo,</span><br><span class="line">                                             uid_t uid,</span><br><span class="line">                                             unsigned int flags)</span><br><span class="line">&#123;</span><br><span class="line">    bool nochange = (flags &amp; SELINUX_ANDROID_RESTORECON_NOCHANGE) ? true : false;</span><br><span class="line">    bool verbose = (flags &amp; SELINUX_ANDROID_RESTORECON_VERBOSE) ? true : false;</span><br><span class="line">    bool recurse = (flags &amp; SELINUX_ANDROID_RESTORECON_RECURSE) ? true : false;</span><br><span class="line">    bool force = (flags &amp; SELINUX_ANDROID_RESTORECON_FORCE) ? true : false;</span><br><span class="line">    bool datadata = (flags &amp; SELINUX_ANDROID_RESTORECON_DATADATA) ? true : false;</span><br><span class="line">    bool skipce = (flags &amp; SELINUX_ANDROID_RESTORECON_SKIPCE) ? true : false;</span><br><span class="line">    bool cross_filesystems = (flags &amp; SELINUX_ANDROID_RESTORECON_CROSS_FILESYSTEMS) ? true : false;</span><br><span class="line">    </span><br><span class="line">    //可见selinux  lib中能支援的参数远比工具包或rc命令中所支援的参数多得多。我们可以根据实际情况修改init或toybox中的restorecon源码，以支援相互之间缺失的参数。</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    bool issys;</span><br><span class="line">    bool setrestoreconlast = true;</span><br><span class="line">    struct stat sb;</span><br><span class="line">    struct statfs sfsb;</span><br><span class="line">    FTS *fts;</span><br><span class="line">    FTSENT *ftsent;</span><br><span class="line">    char *pathname = NULL, *pathdnamer = NULL, *pathdname, *pathbname;</span><br><span class="line">    char * paths[2] = &#123; NULL , NULL &#125;;</span><br><span class="line">    int ftsflags = FTS_NOCHDIR | FTS_PHYSICAL;</span><br><span class="line">    int error, sverrno;</span><br><span class="line">    char xattr_value[FC_DIGEST_SIZE];</span><br><span class="line">    ssize_t size;</span><br><span class="line"></span><br><span class="line">    if (!cross_filesystems) &#123;</span><br><span class="line">        ftsflags |= FTS_XDEV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (is_selinux_enabled() &lt;= 0)  //若selinux关闭，则后续动作均不再执行。</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    __selinux_once(fc_once, file_context_init);</span><br><span class="line">     //加载编译进系统的selinux file_contexts，并调用compute_file_contexts_hash函数计算预设载入系统中的file_contexts hash值。目的是为了后续检查用户是否通过fota或其他方式更新了修改过file_contexts的image。</span><br><span class="line"></span><br><span class="line">    if (!fc_sehandle)</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Convert passed-in pathname to canonical pathname by resolving realpath of</span><br><span class="line">     * containing dir, then appending last component name.</span><br><span class="line">     */</span><br><span class="line">    pathbname = basename(pathname_orig);</span><br><span class="line">    if (!strcmp(pathbname, &quot;/&quot;) || !strcmp(pathbname, &quot;.&quot;) || !strcmp(pathbname, &quot;..&quot;)) &#123;</span><br><span class="line">        pathname = realpath(pathname_orig, NULL);</span><br><span class="line">        if (!pathname)</span><br><span class="line">            goto realpatherr;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        pathdname = dirname(pathname_orig);</span><br><span class="line">        pathdnamer = realpath(pathdname, NULL);</span><br><span class="line">        if (!pathdnamer)</span><br><span class="line">            goto realpatherr;</span><br><span class="line">        if (!strcmp(pathdnamer, &quot;/&quot;))</span><br><span class="line">            error = asprintf(&amp;pathname, &quot;/%s&quot;, pathbname);</span><br><span class="line">        else</span><br><span class="line">            error = asprintf(&amp;pathname, &quot;%s/%s&quot;, pathdnamer, pathbname);</span><br><span class="line">        if (error &lt; 0)</span><br><span class="line">            goto oom;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    paths[0] = pathname;</span><br><span class="line">    issys = (!strcmp(pathname, SYS_PATH)</span><br><span class="line">            || !strncmp(pathname, SYS_PREFIX, sizeof(SYS_PREFIX)-1)) ? true : false;</span><br><span class="line">//检查传入路径是否为/sys目录</span><br><span class="line"></span><br><span class="line">    if (!recurse) &#123; //若未传入-R或-recursive参数(无需遍历)，则检查随后传入的文件路径参数是否有问题。</span><br><span class="line">        if (lstat(pathname, &amp;sb) &lt; 0) &#123;</span><br><span class="line">            error = -1;</span><br><span class="line">            goto cleanup;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error = restorecon_sb(pathname, &amp;sb, nochange, verbose, seinfo, uid);</span><br><span class="line">        //进行单文件(夹)label动作。</span><br><span class="line">        goto cleanup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//此后的动作是recursive模式下的逻辑。</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Ignore restorecon_last on /data/data or /data/user</span><br><span class="line">     * since their labeling is based on seapp_contexts and seinfo</span><br><span class="line">     * assignments rather than file_contexts and is managed by</span><br><span class="line">     * installd rather than init.</span><br><span class="line">     */</span><br><span class="line">    if (!strncmp(pathname, DATA_DATA_PREFIX, sizeof(DATA_DATA_PREFIX)-1) ||</span><br><span class="line">        !strncmp(pathname, DATA_USER_PREFIX, sizeof(DATA_USER_PREFIX)-1) ||</span><br><span class="line">        !strncmp(pathname, DATA_USER_DE_PREFIX, sizeof(DATA_USER_DE_PREFIX)-1) ||</span><br><span class="line">        !fnmatch(EXPAND_USER_PATH, pathname, FNM_LEADING_DIR|FNM_PATHNAME) ||</span><br><span class="line">        !fnmatch(EXPAND_USER_DE_PATH, pathname, FNM_LEADING_DIR|FNM_PATHNAME))</span><br><span class="line">        setrestoreconlast = false;</span><br><span class="line"></span><br><span class="line">    /* Also ignore on /sys since it is regenerated on each boot regardless. */</span><br><span class="line">    if (issys)</span><br><span class="line">        setrestoreconlast = false;</span><br><span class="line"></span><br><span class="line">    /* Ignore files on in-memory filesystems */</span><br><span class="line">    if (statfs(pathname, &amp;sfsb) == 0) &#123;</span><br><span class="line">        if (sfsb.f_type == RAMFS_MAGIC || sfsb.f_type == TMPFS_MAGIC)</span><br><span class="line">            setrestoreconlast = false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //前面有将，此处将sys文件路径、ranfs文件路径和前面提到过的/data/下一系列路径进行标记，对于这些文件路径而言，将不判断file_contexts的hash值是否有变而直接进入后续逻辑。（对其余文件夹，将计算文件夹中存入的file_contexts hash值是否和限制系统中file_contexts的hash一致，若user烧了更换过file_contexts rule的image，则直接按照新rule进行遍历及relabel）</span><br><span class="line"></span><br><span class="line">    if (setrestoreconlast) &#123;</span><br><span class="line">     //对于非 /sys、ramfs和data特定目录的文件路径，将进行进一步检查，来确定recursive动作是否真要要执行。</span><br><span class="line">        size = getxattr(pathname, RESTORECON_LAST, xattr_value, sizeof fc_digest);</span><br><span class="line">        //通过getxattr函数，读取所传入文件node中&quot;security.restorecon_last&quot;属性值，该值对应的数据是上次restorecon执行过程中所存入的file_contexts hash值。</span><br><span class="line">        if (!force &amp;&amp; size == sizeof fc_digest &amp;&amp; memcmp(fc_digest, xattr_value, sizeof fc_digest) == 0) &#123;</span><br><span class="line">        //若不加入force命令，且当前系统的file_contexts hash值与文件node中存入的hash值完全一致（说明系统未更新过sepolicy），则不再进行重复relabel动作，以保证后续操作系统对系统文件selabel所做的改动不被无意义地改变。（这里我们可以通过烧入修改过sepolicy的boot image并重启手机，让已经label过得部分文件再次relabel）</span><br><span class="line">            selinux_log(SELINUX_INFO,</span><br><span class="line">                        &quot;SELinux: Skipping restorecon_recursive(%s)\n&quot;,</span><br><span class="line">                        pathname);</span><br><span class="line">            error = 0;</span><br><span class="line">            goto cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fts = fts_open(paths, ftsflags, NULL);</span><br><span class="line">    if (!fts) &#123;</span><br><span class="line">        error = -1;</span><br><span class="line">        goto cleanup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error = 0;</span><br><span class="line">    while ((ftsent = fts_read(fts)) != NULL) &#123;</span><br><span class="line">        switch (ftsent-&gt;fts_info) &#123;</span><br><span class="line">        case FTS_DC:   //A directory that causes a cycle in the tree. </span><br><span class="line">            selinux_log(SELINUX_ERROR,</span><br><span class="line">                        &quot;SELinux:  Directory cycle on %s.\n&quot;, ftsent-&gt;fts_path);</span><br><span class="line">            errno = ELOOP;</span><br><span class="line">            error = -1;</span><br><span class="line">            goto out;</span><br><span class="line">        case FTS_DP: //A  directory  being  visited  in  postorder.</span><br><span class="line">            continue;</span><br><span class="line">        case FTS_DNR: //A directory which cannot be read.</span><br><span class="line">            selinux_log(SELINUX_ERROR,</span><br><span class="line">                        &quot;SELinux:  Could not read %s: %s.\n&quot;, ftsent-&gt;fts_path, strerror(errno));</span><br><span class="line">            fts_set(fts, ftsent, FTS_SKIP);</span><br><span class="line">            continue;</span><br><span class="line">        case FTS_NS: //A file for which no stat(2) information was available.</span><br><span class="line">            selinux_log(SELINUX_ERROR,</span><br><span class="line">                        &quot;SELinux:  Could not stat %s: %s.\n&quot;, ftsent-&gt;fts_path, strerror(errno));</span><br><span class="line">            fts_set(fts, ftsent, FTS_SKIP);</span><br><span class="line">            continue;</span><br><span class="line">        case FTS_ERR: // This is an error return.</span><br><span class="line">            selinux_log(SELINUX_ERROR,</span><br><span class="line">                        &quot;SELinux:  Error on %s: %s.\n&quot;, ftsent-&gt;fts_path, strerror(errno));</span><br><span class="line">            fts_set(fts, ftsent, FTS_SKIP);</span><br><span class="line">            continue;</span><br><span class="line">        case FTS_D:  //A directory being visited in preorder.</span><br><span class="line">            if (issys &amp;&amp; !selabel_partial_match(fc_sehandle, ftsent-&gt;fts_path)) &#123;</span><br><span class="line">                fts_set(fts, ftsent, FTS_SKIP);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (skipce &amp;&amp;</span><br><span class="line">                (!strncmp(ftsent-&gt;fts_path, DATA_SYSTEM_CE_PREFIX, sizeof(DATA_SYSTEM_CE_PREFIX)-1) ||</span><br><span class="line">                 !strncmp(ftsent-&gt;fts_path, DATA_MISC_CE_PREFIX, sizeof(DATA_MISC_CE_PREFIX)-1))) &#123; //若restorecon带入了--recursive和--skip-ce参数，则跳过/data/misc_ce/和/data/system_ce/两个ce目录的relabel过程。</span><br><span class="line">                // Don&apos;t label anything below this directory.</span><br><span class="line">                fts_set(fts, ftsent, FTS_SKIP);</span><br><span class="line">                // but fall through and make sure we label the directory itself</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!datadata &amp;&amp;</span><br><span class="line">                (!strcmp(ftsent-&gt;fts_path, DATA_DATA_PATH) ||</span><br><span class="line">                 !strncmp(ftsent-&gt;fts_path, DATA_USER_PREFIX, sizeof(DATA_USER_PREFIX)-1) ||</span><br><span class="line">                 !strncmp(ftsent-&gt;fts_path, DATA_USER_DE_PREFIX, sizeof(DATA_USER_DE_PREFIX)-1) ||</span><br><span class="line">                 !fnmatch(EXPAND_USER_PATH, ftsent-&gt;fts_path, FNM_LEADING_DIR|FNM_PATHNAME) ||</span><br><span class="line">                 !fnmatch(EXPAND_USER_DE_PATH, ftsent-&gt;fts_path, FNM_LEADING_DIR|FNM_PATHNAME))) &#123;</span><br><span class="line">                 //若未传入SELINUX_ANDROID_RESTORECON_DATADATA flag（即restorecon工具的-D的参数），则默认跳过上节提到的/data/目录内一系列目录的relabel过程。</span><br><span class="line">                // Don&apos;t label anything below this directory.</span><br><span class="line">                fts_set(fts, ftsent, FTS_SKIP);</span><br><span class="line">                // but fall through and make sure we label the directory itself</span><br><span class="line">            &#125;</span><br><span class="line">            /* fall through */</span><br><span class="line">        default:</span><br><span class="line">            error |= restorecon_sb(ftsent-&gt;fts_path, ftsent-&gt;fts_statp, nochange, verbose, seinfo, uid);//对于其余的正常文件路径，调用restorecon_sb函数进行正常的restorecon动作。</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Labeling successful. Mark the top level directory as completed.</span><br><span class="line">    if (setrestoreconlast &amp;&amp; !nochange &amp;&amp; !error)</span><br><span class="line">        setxattr(pathname, RESTORECON_LAST, fc_digest, sizeof fc_digest, 0);</span><br><span class="line">        //将最新的系统sepolicy hash值，写入relabel过的文件路径根目录node中，以便后续不在进行多余的relabel动作。</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    sverrno = errno;</span><br><span class="line">    (void) fts_close(fts);</span><br><span class="line">    errno = sverrno;</span><br><span class="line">cleanup:</span><br><span class="line">    free(pathdnamer);</span><br><span class="line">    free(pathname);</span><br><span class="line">    return error;</span><br><span class="line">oom:</span><br><span class="line">    sverrno = errno;</span><br><span class="line">    selinux_log(SELINUX_ERROR, &quot;%s:  Out of memory\n&quot;, __FUNCTION__);</span><br><span class="line">    errno = sverrno;</span><br><span class="line">    error = -1;</span><br><span class="line">    goto cleanup;</span><br><span class="line">realpatherr:</span><br><span class="line">    sverrno = errno;</span><br><span class="line">    selinux_log(SELINUX_ERROR, &quot;SELinux: Could not get canonical path for %s restorecon: %s.\n&quot;,</span><br><span class="line">            pathname_orig, strerror(errno));</span><br><span class="line">    errno = sverrno;</span><br><span class="line">    error = -1;</span><br><span class="line">    goto cleanup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要补充的是，使用setxattr函数向文件夹node中存入的hash值，其实是存到了真正的文件系统中，并不会随着关机或重启而发生变化。这样就让我们有机会通过判断用户是否更新了带新file_contexts rule的image，来决定在调用restorecon_recursive时，对于未修改过sepolicy rule的文件节点就不再重复进行relabel动作了。</p>
<h2 id="饭后甜点"><a href="#饭后甜点" class="headerlink" title="饭后甜点"></a>饭后甜点</h2><p>带来一个经典的案例作为饭后甜点：</p>
<blockquote>
<p>一位user从Android O Fota退版回Android N,此后再次想进行Fota升级<br>却发现系统卡在recovery mode再也无法出来。即使此时强按power key进行重启，依然会自动进入recovery mode。</p>
<p>值得注意的是：其他user均未回报此问题，即该问题或许只有在特殊的操作手法下才能复现。</p>
</blockquote>
<p>这里先直接给出debug后的结论：</p>
<blockquote>
<p> 在Android N 的img中，开始fota并进入recovery image后，主进程会试图读取adc分区中的log文件，以便将recovery过程的关键log存入其中。但该机器的log文件selinux label却是”u:object_r:log_file:s0“，故permission denied，系统逻辑直接跳出，故卡死在recovery中。另外，由于misc分区的command和cache分区的command都未被清除，所以再次开机自然也会进入recovery mode。</p>
</blockquote>
<p>这里我们首先要弄清楚两个问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 为何recovery mode 中必须打开abc分区的log文件并且打开失败就直接退出？</span><br><span class="line"></span><br><span class="line">为了方便debug，RD将recovery过程中的一部分log冲定向到abc分区，以便能永久保存避免误删。</span><br><span class="line">而打开失败就退出，应该是coding bug。</span><br><span class="line"></span><br><span class="line">2. log文件的sepolicy到底为何改变了？</span><br><span class="line"></span><br><span class="line">在Android N中，我们未对adc分区做特别的selinux label动作，故abc分区中的所有文件默认都是unlabeled sepolicy权限。而Android O中，我们有针对对adc分区加入了 ”u:object_r:log_file:s0“  label以便对log权限进性规范化统一。 </span><br><span class="line"></span><br><span class="line">问题机器在Android N的recovery中，查看abc分区内所有文件，发现其他文件都是unlabeled状态，唯独log文件是log_file状态。而同样操作后，正常机器内的abc分区文件label 都是unlabeled。</span><br><span class="line"></span><br><span class="line">所以该文件的selinux label改变必有玄机。而该玄机就是mount时的强行加入selabel导致。</span><br></pre></td></tr></table></figure></p>
<p>大家知道，若在rc文件中mount分区时</p>
<blockquote>
<p>mount ext4 /dev/block/bootdevice/by-name/asdf /abc rw noatime nosuid nodev barrier=1 data=ordered context=u:object_r:log_file:s0</p>
</blockquote>
<p>直接加入context=“*”参数,则分区mount后，默认文件夹及根目录将默认被植入log_file的selabel，且该selabel其实只是记录在ram中，并未实际写入文件系统。但若此时新建一个文件，则新建文件的selabel却真真正正地被写入了文件系统中。</p>
<p>这就带来一个问题，若以不加context=“*”参数的方式再次mount该分区，则前面新建的文件由于selabel被写入文件系统，故将会保留log_file的selabel，而其余文件会变成unlabeled的selabel。</p>
<p>前面用户遇到的无法fota问题就是因为log文件是在Android O中新建出来的(Android N中没有进入过recovery mode，而是直接用fastboot进行的刷机)，而正常用户都是fota升级，所以在Android N中已经新建出了log文件。这样在Android O中以“context=u:object_r:log_file:s0”的方式mount abc分区的结果是，所有在Android N中存在过的文件均被强行label成log_file到ram中，故不论Android N中文件的label怎样及是否进行新的文件创建(写入实际文件系统)，均不影响Android O的selinux权限。</p>
<p>但当用户将系统回退到Android N的recovery image后，由于Android N未进行mount加context=“*”参数的动作，故在Android O中新建立的文件label(实际写入文件系统中)就显现出正式的模样，即log文件的label变成了log_file的label。</p>
<p>补充一个问题，<strong>为何只有新建的文件，其selinux的label才会被写入文件系统呢？</strong></p>
<p>问题的答案在restorecon函数的实现中可以找到端倪：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static int restorecon_sb(const char *pathname, const struct stat *sb,</span><br><span class="line">                         bool nochange, bool verbose,</span><br><span class="line">                         const char *seinfo, uid_t uid)</span><br><span class="line">&#123;</span><br><span class="line">    char *secontext = NULL;</span><br><span class="line">    char *oldsecontext = NULL;</span><br><span class="line">    int rc = 0;</span><br><span class="line"></span><br><span class="line">    if (selabel_lookup(fc_sehandle, &amp;secontext, pathname, sb-&gt;st_mode) &lt; 0)</span><br><span class="line">        return 0;  /* no match, but not an error */</span><br><span class="line"></span><br><span class="line">    if (lgetfilecon(pathname, &amp;oldsecontext) &lt; 0)</span><br><span class="line">        goto err;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line">    if (strcmp(oldsecontext, secontext) != 0) &#123;</span><br><span class="line">    </span><br><span class="line">    //若系统发现现有的selinux label已经符合预期(mount时加参数强行label导致)，则不在进行写入实际文件系统的后续动作。所以对于新建的文件而言，其值将会写入文件系统中而不仅仅存在与ram。</span><br><span class="line">        if (verbose)</span><br><span class="line">            selinux_log(SELINUX_INFO,</span><br><span class="line">                        &quot;SELinux:  Relabeling %s from %s to %s.\n&quot;, pathname, oldsecontext, secontext);</span><br><span class="line">        if (!nochange) &#123;</span><br><span class="line">            if (lsetfilecon(pathname, secontext) &lt; 0)</span><br><span class="line">                goto err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rc = 0;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    freecon(oldsecontext);</span><br><span class="line">    freecon(secontext);</span><br><span class="line">    return rc;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    selinux_log(SELINUX_ERROR,</span><br><span class="line">                &quot;SELinux: Could not set context for %s:  %s\n&quot;,</span><br><span class="line">                pathname, strerror(errno));</span><br><span class="line">    rc = -1;</span><br><span class="line">    goto out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以建议大家将selinux的label定义到file_contexts中以便进行更一般化的管理，尽量避免在mount文件系统的时候加入context=“<em>”参数，这样很容易麻痹自己和同事，造成不必要的兼容性问题。 故再次强调，请千万慎用mount时候加如context=“</em>”以求打入label的做法。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/17/New-Themal-Flow-In-Android-O/" rel="next" title="手机卡顿事件与Cpu频率大盗">
                <i class="fa fa-chevron-left"></i> 手机卡顿事件与Cpu频率大盗
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Bevis</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#案例：一个由selinux权限变化所引发的血案"><span class="nav-number">1.</span> <span class="nav-text">案例：一个由selinux权限变化所引发的血案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android系统中嵌入的selinux辅助工具"><span class="nav-number">2.</span> <span class="nav-text">Android系统中嵌入的selinux辅助工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#restorecon-R（recurse）"><span class="nav-number">2.1.</span> <span class="nav-text">restorecon -R（recurse）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#restorecon-D"><span class="nav-number">2.2.</span> <span class="nav-text">restorecon -D</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#restorecon-F"><span class="nav-number">2.3.</span> <span class="nav-text">restorecon -F</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入理解Android-init-rc-命令中集成的restorecon命令"><span class="nav-number">3.</span> <span class="nav-text">深入理解Android init.rc 命令中集成的restorecon命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#rc文件中的restorecon命令"><span class="nav-number">3.1.</span> <span class="nav-text">rc文件中的restorecon命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rc文件中的restorecon-recursive命令"><span class="nav-number">3.2.</span> <span class="nav-text">rc文件中的restorecon_recursive命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#restorecon和restorecon-recursive在init中的具体实现"><span class="nav-number">3.3.</span> <span class="nav-text">restorecon和restorecon_recursive在init中的具体实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#饭后甜点"><span class="nav-number">4.</span> <span class="nav-text">饭后甜点</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bevis</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  









  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
